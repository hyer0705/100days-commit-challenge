# 지난 10일 나의 목표는?!
- [ ] 앱의 모양새가 보기 꽤 그럴듯한 과정 까지 진행하기

# 10일 돌아보면 잘한 점
- 남았던 리팩토링 모두 마무리하고 10일 동안 꾸준히 작업했다.

# 10일 돌아보며 아쉬운 점
- 그리기 작업을 모두 완료하지 못했다. 목표를 너무 크게 잡지 말아야겠다 (ㅋㅋ)

# 10일 동안 공부한 내용
현재 진행 프로젝트: WinAPI로 지뢰찾기 만들기
목표: C++ 공부

- C++

  - 가상 소멸자
    C++ 에서 기본 클래스의 경우 가상 소멸자를 정의하는 것이 중요하다.
    이유는 만일 아래 같은 상황에서 기본 클래스의 소멸자가 가상 함수가 아니면 기본 클래스의 소멸자만 호출되고 파생 클래스의 소멸자는 호출되지 않아 파생 클래스 내 리소스 때문에 메모리 누수가 발생할 가능성이 있다. 
    A* obj = new B();
    delete obj; // A의 소멸자가 가상이 아니면 A 의 소멸자만 호출되고 B 는 호출되지 않음.

    소멸자에서 특별히 처리할 내용이 없어서 정의해주기 귀찮으면 아래처럼 default 를 박아버리면 된다.
    virtual ~A() = default;

  - 메모리 해제 관련
    작업하면서 이 애는 메모리를 해제 안해줘도 되나? 가 계속 궁금했었다. 안해줘도 되는 녀석들 중 좀 헷갈렸던 애들만 메모해보았다.

    - TCHAR: 문자열 리터럴으로, 프로그램이 시작될 때 정적 메모리 영역에 할당된다.
    - HWND: WIndows API내에서 생성하는 리소스로 운영체제가 관리한다. 애플리케이션 종료 시 메모리가 자동으로 해제된다.
    - RECT: 구조체이다. 스택에 저장된다. 왜 헷갈렸을까...

  - 스마트 포인터
    C++ 11 이상에서 사용 가능하다. 메모리 해제를 자동으로 해준다. 아래와 같은 방법으로 사용한다.
    
    #include <memory>

    std::shared_ptr<A> GetA() 
    { 
      std::shared_ptr<A> a = std::make_shared<A>(); // 스마트 포인터로 동적 메모리 할당
      return a; // 스마트 포인터 반환
    }

  - this 포인터
    클래스 내에서 자기 자신 참조할 때 사용. 
    A& a = *this;

  - 람다 함수의 캡션
    람다 함수를 선언했을 때, [] 안에 포인터를 넣어 사용할 수 있다.
    예) auto lamda = [this]() { this->DoSomething(); }

  - 버튼이 눌린 듯한 연출 주기
    WM_DRAWITEM 에서 LPDRAWITEMSTRUCT 타입으로 해당되는 버튼 아이템을 받은 후, 눌린 상태에 따라 DrawEdge 함수에 다른 값을 전달한다.
    
    LPDRAWITEMSTRUCT lpDrawItem = (LPDRAWITEMSTRUCT)lParam;

    if (lpDrawItem->itemState & ODS_SELECTED) // 버튼이 눌린 상태
    {
        // 눌린 상태의 버튼을 그린다.
        DrawEdge(lpDrawItem->hDC, &lpDrawItem->rcItem, EDGE_SUNKEN, BF_RECT);
    }
    else // 기본 상태
    {
        // 기본 상태의 버튼을 그린다.
        DrawEdge(lpDrawItem->hDC, &lpDrawItem->rcItem, EDGE_RAISED, BF_RECT);
    }

  - 함수 내 static 변수 선언
    함수 내부에서 선언된 로컬 변수는 함수가 종료되면 해제되므로 사용할 수 없게 되므로 해당 값을 반환했을 때 비정상적으로 작동한다. 
    하지만 static 변수는 데이터 영역에 저장되며, 함수가 끝나더라도 해제되지 않고 프로그램이 종료될 때까지 유지된다.
    **참고: C++에서 메모리는 크게 스택, 힙, 데이터 영역으로 구분됨
    static 변수는 함수가 처음 호출될 때 한 번만 초기화되므로, 해당 함수를 많이 호출한다고 해서 성능에 문제가 발생하지는 않는다.
    다만 여러 함수에서 static 변수를 선언하고 있을 경우 그만큼 메모리를 사용량이 증가하는 문제가 발생할 수 있다.
    멀티스레딩 환경에서 static 변수를 여러 스레드가 동시에 접근하는 경우도 주의해야 한다.


- WinAPI 

  - 더블 버퍼링
    그래픽스에서 화면 깜빡임을 줄이기 위한 기술이다. 실제 화면에 그리기 작업을 하기 전 메모리에서 준비한 별도의 버퍼에 작업을 처리한 후, 그 결과를 한 번에 화면에 복사하는 방식이다.

  - COLORREF
    RGB() 매크로의 반환 값

  - 시스템에서 제공하는 기본 색상 브러쉬
    
    FillRect(hdc, &rect, (HBRUSH)(COLOR_WINDOW + 1)); 라는 코드에서 COLOR_WINDOW + 1 가 의미하는 것이 무엇이고 왜 HBRUSH로 바로 캐스팅이 가능한 것인지 궁금해서 찾아보았다.
    COLOR_WINDOW, COLOR_MENU 등 기본 시스템 색상 브러쉬가 존재하고, COLOR_~~ + 1 형식으로 사용해서 브러쉬 핸들을 얻을 수 있다고 한다.

  - 색상 그릴 때 알파 값 사용하기
    기본적으로 WinAPI의 RGB() 함수는 알파값을 넣을 수 없다. 따라서 RGBA() 함수를 사용해야 하는데... 내가 프로젝트에서 주로 잘 쓰고있는 GDI 브러쉬, FillRect 함수에서는 이를 지원하지 않는다.
    따라서 투명도를 처리하려면 알파 블렌딩이라는 기술을 직접 구현해야 한다고 한다..

  
# 앞으로 10일 동안 나의 목표는?!
- [ ] 못다한 그리기 작업 완료하기.