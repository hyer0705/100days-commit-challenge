# 지난 10일 나의 목표는?!
- [X] (2트) 프로젝트의 기본적인 작동 플로우 완성하기 (게임 시작 -> 결과)
- [X] 미뤘던 리팩토링 진행하기

# 10일 돌아보면 잘한 점
- 리팩토링이 원하는 그림대로 잘 진행됐다.

# 10일 돌아보며 아쉬운 점
- 리팩토링을 매일 너무 찔끔씩만 해서 흐름이 끊기는 것이 아쉬웠다. 역시 이런 건 하루 날잡고 해야하나보다. 
  사실 아직 좀 남았다. 주말에 해야겠다.

# 10일 동안 공부한 내용
현재 진행 프로젝트: WinAPI로 지뢰찾기 만들기
목표: C++ 공부

- 신나는 리팩토링 회고
  - 비동기 과정 (타이머, 스레드) 다루는 모듈 분리 작업

      여러가지 비동기 과정을 한번에 오류 없이 다룰 수 있는 모듈을 제작했다.
      비동기 과정을 시작할 때 모듈에 int 값을 키, std::function 값의 람다식을 value 로 전달해서 map 형태로 들고 있는다. 
      Start, Stop 에서 map 을 활용해 각 과정이 충돌되는 오류를 방지한다. 
      객체가 파괴될 때 진행중인 비동기 과정을 모두 메모리에서 해제 처리 해주었다.

      ~ std::thread 로 스레드 매니저 만들기 대작전 ~
      - Start, Stop 등의 일을 처러하기 전 아래 구문으로 중첩 오류를 방지했다.
        std::lock_guard<std::mutex> lock(mutex);
        mutex(뮤텍스)는 다중 스레드 환경에서 공유 자원을 보호하기 위한 동기화 메커니즘이다. 여러 스레드가 동시에 공유 자원에 접근하려고 할 때, mutex를 사용하면 한 번에 하나의 스레드만 그 자원에 접근할 수 있도록 제한할 수 있다고 한다.
      
      - 스레드는 메인 스레드가 아닌 곳에서 중지하면 abort 가 발생하길래 스레드의 진행 여부를 컨트롤 하는 std::atomic<bool> 타입의 플래그 값을 과정 별로 추가해주었다. 
        플래그 값, 스레드를 묶은 구조체를 map 의 value 값으로 저장해서 사용했다.
        그런데 스레드는 복사를 할 수 없고 이동만 가능한 객체라서 map에 넣어주기 위해 아래 작업들을 진행해야 했다 ㅋㅋ
          - 구조체의 복사 생성자 제거
          - 구조체에 이동 할당 연산자 추가
          - 구조체 생성자를 명시적으로 추가해서 이동 연산자만 사용하도록 처리
          - map 에 구조체 넣어줄 때 emplace 함수 사용
              emplace 함수는 컨테이너에 객체를 삽입할 때 객체를 복사하거나 이동하지 않고 컨테이너 내부에서 직접 객체를 생성하는 방식으로 동작한다.
              insert와 비교했을 때: insert는 이미 생성된 객체를 삽입하므로 이 과정에서 복사or이동 이 발생하지만 emplace 는 객체를 그 자리에서 생성하므로 불필요한 과정을 제거할 수 있음.
              상황에 따라서 insert / emplace 중 어떤 걸 쓸지 잘 판단해야 할듯 

  - 윈도우 관리 매니저와 개별 창 모듈 분리 작업
      
      지금까지 코드의 문제점 :
      - WinProc 함수 내 switch 문에 우겨넣은 내용들이 너무 많아서 보기 너무 복잡함.
      - 창을 포함한 창 내 핸들의 생성/파괴 주기를 파악하기 너무 어려움.

      아래 방법으로 해결해보았음 :
      - 창의 생성/파괴, 메시지 처리 등 앱의 전체적인 생로병사(?)를 관리하는 윈도우 핸들 매니저 추가. 
      - WinProc 함수를 위 매니저의 정적 멤버로 넣어줌
      - 창 핸들을 클래스화 하고 OnCreate, OnPaint 등의 기본 함수들을 virtual 로 추가
      - 윈도우 핸들 매니저에서 현재 조작하고 있는 창 객체의 포인터를 들고 있고, WinProc 함수에서는 해당 객체의 virtual 함수들만 호출해준다.
      - 각 창은 클래스화한 창 핸들을 상속받는 클래스의 형태로 구현한다.
    

- 이것저것 메모

  - Windows API 만의 문서화된 타입이 있다. 예를 들어 UINT 와 unsinged int 는 사실상 같은 타입이지만 UINT 는 Windows API 의 일부로 정의되어 있으며 특정 크기를 보장하고 일관성을 유지한다.
      결론: API 를 활용할 때에는 API 문서의 일관성을 지키는 것도 중요하다.

  - 타이머를 활용하면서 KillTimer을 호출할 때 앞에 ::을 붙여 ::KillTimer로 호출해주었는데 이유는 C++전역 네임스페이스의 함수임을 명시하기 위해서였다. 함수명이 중복될 가능성이 다분하기 때문.

  - GetClientRect 함수
      특정 윈도우의 클라이언트 영역을 가져올 때 활용. 클라이언트 영역은 윈도우의 타이틀 바, 메뉴 바, 테두리 등을 제외한 실제 콘텐츠가 표시되는 영역.

  - WinAPI 에서 RECT 구조체 멋있게 다루기
    - SetRect 함수 사용 : RECT의 포인터 값을 인자로 받아 사용하므로 값 복사가 일어나지 않는다.
    - InflateRect : RECT의 크기만 변경하고 싶을 때 활용
    - OffsetRect : RECT의 위치만 변경하고 싶을 때 활용

  - 싱글톤 패턴 남발하는 것이 고민일 때 대체로 사용하기 좋은 수단
    - 의존성 주입 패턴 (DI: Dependency Injection)
    - 옵저버 패턴
    - 서비스 중개자 패턴
    - 이벤트 기반 아키텍처
      
  
# 앞으로 10일 동안 나의 목표는?!
- [ ] 앱의 모양새가 보기 꽤 그럴듯한 과정 까지 진행하기