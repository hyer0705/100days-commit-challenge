# 지난 10일 나의 목표는?!

- [ ] 하루에 10분 스트레칭, 10분 운동하기!!!
- [x] 우테코 지원하기
- [ ] 인프런 워밍업 클럽 스터디 2기 프론트엔드 참여 및 2주차 과제 50% 이상 해내기~

# 10일 돌아보면 잘한 점

- 우테코 지원서 늦지 않게 제출했다.
- 벨만 포드 알고리즘 이해될 때까지 포기하지 않고 여러 자료를 찾아보면서 공부했다.
  - 요즘엔 그 날 이해가 가지 않는다고 좌절하지 않는 태도를 가지게 된 것 같다. 오늘 이해가 가지 않으면 내일은 이해가 가지 않을까? 처음엔 누구나 어려우니까 오늘은 어렵고 내일은 쉽게 느껴지지 않을까? 하는 생각을 가지고 공부를 하니까 스트레스를 덜 받게 됐다.

# 10일 돌아보며 아쉬운 점

- 프로젝트 캠프가 끝나고 단기 알바를 하게 됐는데 그 알바 때문에 챌린지에 쓸 시간이 줄어들어서 적극적으로 참여를 못했다...! 그래서 몇 번 커밋을 놓쳤다... 다시 하루에 1시간은 챌린지에 투자할 수 있도록 계획을 짜야겠다.

# 10일 동안 공부한 내용

- 벨만 포드 알고리즘
  - 정의 및 특징
    - Bellman-Ford 알고리즘은 본질적으로 하나의 시작 정점에서 출발해 가중치 그래프의 다른 모든 정점까지의 최단 경로를 찾는 것을 목표로 합니다.
    - 이 알고리즘은 방향 그래프나 무방향 그래프 모두에서 작동할 수 있는 유연성을 가지고 있습니다. 특히, Dijkstra 알고리즘과 달리 음수 가중치를 가진 간선도 처리할 수 있다는 점이 큰 특징입니다.
  - 동작하는 원리
    - 초기화: 각 노드는 임시 거리 값을 부여받습니다. 시작 노드의 거리는 0으로 설정되고, 다른 모든 노드는 무한대로 설정됩니다. 처음에는 각 노드의 선행 정점(이전 경로)이 정의되지 않은 상태로 표시됩니다.
    - 메인 루프: 루프는 그래프의 정점 수가 n일 때, n-1 번 반복됩니다.
    - 음수 가중치 사이클 확인: 메인 루프가 끝난 후에도 여전히 간선을 완화할 수 있다면, 이는 그래프에 음수 가중치 사이클이 존재한다는 것을 나타냅니다. 음수 사이클이 있으면, 이 사이클을 반복하면 항상 더 짧은 경로가 만들어지므로 최단 경로가 정의되지 않게 됩니다.
  - 장단점
    - 장점
      - 음수 가중치 처리: 다른 일부 알고리즘과 달리, Bellman-Ford 알고리즘은 음수 가중치를 처리하는 데 어려움이 없습니다.
      - 음수 사이클 감지: 음수 사이클이 있을 경우 이를 감지하고 보고할 수 있습니다.
    - 단점
      - 속도: 음수 가중치가 없는 그래프에서는 Bellman-Ford가 Dijkstra 알고리즘에 비해 느립니다.
      - 음수 사이클에서의 경로 정의 불가: 시작점에서 도달 가능한 음수 사이클이 있으면 최단 경로를 정의할 수 없습니다.
  - 사용하는 경우?
    - Bellman-Ford 알고리즘은 특히 음수 가중치가 포함된 상황에서 최단 경로 문제를 해결하는 데 강력한 솔루션을 제공합니다.
    - 예를 들어, 통화 환전에서의 차익 거래 기회 탐지나 다양한 비용의 네트워크 라우팅에서 음수 사이클을 감지해야 할 때 매우 가치가 있습니다.
  - 참고 자료
    - [The Bellman-Ford Algorithm Explanation With Examples In Ruby, Javascript And Python](https://patrickkarsh.medium.com/the-bellman-ford-algorithm-explanation-with-examples-in-ruby-javascript-and-python-164c39e2842e)
- IIFE(즉시 실행 함수)
  - Immediately Invoked Function Expression: 정의되자마자 즉시 실행되는 Javascript Function을 말한다.
  - 기본적인 형태
    ```javascript
    (function () {
      // code...
    })();
    ```
  - IIFE의 주된 사용 목적
    - 변수를 전역(global scope)으로 선언하는 것을 피하기 위해서입니다. 또한, IIFE 내부 안으로 다른 변수들이 접근하는 것을 막을 수도 있습니다.
    ```javascript
    const increment = (() => {
      let counter = 0;
      const number = (num) => console.log(num);
      return () => {
        counter++;
        number(counter);
      };
    })(); // 해당 코드는 increment() 를 호출할 때마다 counter의 값이 1씩 증가하고 counter의 값을 출력해준다.
    ```
  - 참고 자료
    - [강의: 따라하며 배우는 자바스크립트 A-Z, John Ahn](https://www.inflearn.com/course/%EB%94%B0%EB%9D%BC%ED%95%98%EB%A9%B0-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8)

# 앞으로 10일 동안 나의 목표는?!

- [ ] 주 3회 이상 15~30분 러닝하기
- [ ] 우테코 프리코스 열심히하기
- [ ] `쏙쏙 들어오는 함수형 코딩` Chapter 3까지 읽고 정리하기
